[{"title":"动态规划背包问题","date":"2024-04-09T05:05:48.000Z","url":"/2024/04/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","categories":[["undefined",""]],"content":"01背包问题Description有一个固定大小的背包，以及一组物品，每件物品都有自己的重量和价值，需要确定装入背包的物品的组合，使得装入背包的物品总重量不超过背包的容量，且所装物品的总价值最大。 每种物品只能选择装入一次，即要么装入背包，要么不装入。 Solution第i个物品的重量为weights[i] 第i个物品的价值为values[i] 背包的最大容量为capacity 定义一个二位数组dp[i][j]表示前个i物品装入容量为j的背包的最大价值 第一重循环从前个1物品到前n个物品依次遍历 第二重循环从背包容量为1到背包容量为capacity依次遍历 显然可知前0个物品的背包最大价值为0，背包最大容量为0的最大价值为0 第二重循环遍历时分两种情况，第i个物品的质量大于当前背包最大容量，dp取前i-1个物品时的背包容量；第i个物品的质量小于等于当前背包最大容量，取前i-1个物品时背包容量为j的最大容量（i-1的循环已得出）与前i-1个物品时（背包容量为j减去当前第i个物品的质量）加上当前物品的价值之间的最大值注意第i个物品的质量和价值的下标为i-1 最后得到的dp[n][capacity]即为所求最大值 完全背包问题Description有一个固定大小的背包，以及一组物品，每件物品都有自己的重量和价值，需要确定装入背包的物品的组合，使得装入背包的物品总重量不超过背包的容量，且所装物品的总价值最大。 每种物品可以无限次选择装入，即可以重复装入多次。 Solution在01背包问题中由于每种物品只能放一次，dp[i][j]只能是dp[i - 1][j]与前i-1个物品减去当前物品质量weight[i-1]得到的dp[i-1][j - weights[i-1]]加上当前物品价值之间的最大值 而完全背包问题中，可以重复加入同一物品，即与可能加入过本物品的背包再加入当前物品dp[i][j - weights[i-1]] + values[i-1])相比 总结动态规划（Dynamic Programming，DP）是一种解决多阶段决策问题的数学方法，通常用于优化问题。其原理基于将一个问题分解成多个子问题，并且通过对这些子问题的解进行存储，以避免重复计算，从而减少时间复杂度。 动态规划的核心思想是利用之前计算过的结果来减少重复计算，从而提高算法的效率。它通常适用于具有最优子结构性质和重叠子问题性质的问题。最优子结构指的是问题的最优解可以通过子问题的最优解来构造，而重叠子问题指的是问题的子问题会被重复求解多次。 如在本问题中，将问题划分为n个小问题，记录此前的最大价值，依次为依据减少计算量 动态规划一般有两种解决方法：自顶向下的备忘录法和自底向上的递推法。备忘录法通常采用递归的方式解决问题，并使用一个数组（通常称为备忘录）来存储已经计算过的结果，避免重复计算。递推法则是从最小的子问题开始，逐步推导出更大规模问题的解，直到求解出整个问题的解。"},{"title":"Best Time to Buy and Sell Stock IV","date":"2024-04-08T09:16:58.000Z","url":"/2024/04/08/Best-Time-to-Buy-and-Sell-Stock-IV/","categories":[["undefined",""]],"content":"DescriptionYou are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k. Find the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Example 1: Example 2: Constraints: 1 &lt;= k &lt;= 100 1 &lt;= prices.length &lt;= 1000 0 &lt;= prices[i] &lt;= 1000 Solution思路同Best Time to Buy and Sell Stock III "},{"title":"Best Time to Buy and Sell Stock III","date":"2024-04-07T13:18:12.000Z","url":"/2024/04/07/Best-Time-to-Buy-and-Sell-Stock-III/","categories":[["undefined",""]],"content":"DescriptionYou are given an array prices where prices[i] is the price of a given stock on the ith day. Find the maximum profit you can achieve. You may complete at most two transactions. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Example 1: Example 2: Example 3: Constraints: 1 &lt;= prices.length &lt;= 105 0 &lt;= prices[i] &lt;= 105 Solution解法一分为四种状态，第一次购买后，第一次卖出后，第二次购买后，第二次卖出后，分别为dp[i][0] dp[i][1] dp[i][2] dp[i][3] ，其中 i代表天数 第一天假设买了股票，所以设置dp[0][0]为prices[0] 至于设置dp[0][2]为prices[0],是为了防止在只卖一次的情况下对最终结果造成干扰，因为第一次买入值为负，但dp[0][2]的值为0，假设只买入一次，在股票涨到最高值时，dp[i][0]依旧小于0因此dp[i][1]（即卖出后得到的钱），小于股票最高价；而dp[i][3]却为股票最高价导致最后得到的结果出现偏差。得到一个结论：变量使用前要记得初始化为正确的值 解法二在解法一中可以发现,dp数组只访问了上一次的值，而与此前历史的值无关，因此二维数组可以简化为四个变量dp0 dp1 dp2 dp3 "},{"title":"Linux command","date":"2024-04-04T14:22:12.000Z","url":"/2024/04/04/Linux-command/","categories":[["undefined",""]],"content":" 使用SSH连接Linux服务器： 本机与Linux上传下载文件 从Linux服务器下载文件（文件夹）到本机 从本机上传文件（文件夹）到Linux服务器 Linux 开放端口 开启防火墙 systemctl start firewalld 开放指定端口firewall-cmd --zone=public --add-port=8848/tcp --permanent--zone 作用域-add-port=1935/tcp 添加端口，格式为：端口&#x2F;通讯协议--remove-port=1935/tcp 关闭指定端口--permanent 永久生效，没有此参数重启后失效 查看指定端口firewall-cmd --list-ports 重启防火墙firewall-cmd --reload 查看端口号netstat -ntlp 查看当前所有tcp端口netstat -ntulp |grep 8848 查看所有8848端口使用情况 查询进程端口占用 ps -ef | grep [进程名] Linux 操作文件 rm -rf 目录名 删除目录连同目录下所有文件 .tar.gz 和 .tgz 解压：tar -zxvf FileName.tar.gz 压缩：tar -zcvf FileName.tar.gz DirName mkdir [-p] dirName-p 确保目录名称存在，不存在的就建一个。 mv file1 /tmp 移动到指定目录 mv file1 file2 重命名文件 mv dir1 dir2 移动目录dir1到dir2 mv file1 file2 dir1 移动多个文件到目标目录 mv *.pdf ~/Documents cp source.txt destination.txt 复制文件到另一个位置 cp -r source_dir destination_dir 递归复制整个目录 IPv4 转发 sysctl net.ipv4.ip_forward 查看虚拟机是否开启ipv4转发 sysctl -w net.ipv4.ip_forward=1 开启ipv4转发 "},{"title":"combinations and permutation","date":"2024-04-04T10:43:27.000Z","url":"/2024/04/04/combinations-and-permutation/","categories":[["undefined",""]],"content":" Combinations Permutations "}]