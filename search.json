[{"title":"Merge k Sorted Lists","date":"2024-04-22T10:22:02.000Z","url":"/2024/04/22/Merge-k-Sorted-Lists/","tags":[["LeetCode","/tags/LeetCode/"],["Algorithm","/tags/Algorithm/"]],"categories":[["undefined",""]],"content":"DescriptionYou are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. Example 1: Example 2: Example 3: Constraints: k == lists.length 0 &lt;= k &lt;= 104 0 &lt;= lists[i].length &lt;= 500 -104 &lt;= lists[i][j] &lt;= 104 lists[i] is sorted in ascending order. The sum of lists[i].length will not exceed 104. Solution思路分析有两种思路 每两个链表一对将其合并，以减少链表的条数，最终缩减为一条即为最终所求 同时合并多条链表,选取其中非空链表中的未合并的元素中的最小值作为合并链表的下一个节点，依次插入 算法优化的核心在于降低选取最小元素时的复杂度 如果是常规思路，需要遍历所有链表剩余的头节点，选取其中的最小值，算法复杂度为O(n) 可以发现每次遍历选取最小值后只删去一个元素，添加一个元素，原来的元素顺序还基本保持不变，我们只需在原来顺序的基础上删去元素，插入新元素即可，对于顺序的记录，可以使用一个堆来实现，插入只需要O(logn)的时间复杂度，而c++和java中的优先队列底层便是使用了堆的数据结构 代码讲解c++中有重载运算符的用法，介于原链表数据结构不可变，新建了一个Status结构体来实现 优先队列通过&lt;来对元素进行排序，因此重载了比较运算符 将链表的头部依次插入优先队列，每次选取优先队列头部作为合并链表后继，并将原队列头节点后移作为新插入元素，新插入的元素又会进行排序，保证每次插入合并队列的都是剩余队列中的最小值，以实现合并 时间复杂度：O(kn*logk) 空间复杂度：O(k) 其中k为链表条数，kn为总元素个数"},{"title":"Construct Quad Tree","date":"2024-04-21T12:06:38.000Z","url":"/2024/04/21/Construct-Quad-Tree/","tags":[["LeetCode","/tags/LeetCode/"],["Algorithm","/tags/Algorithm/"]],"categories":[["undefined",""]],"content":"DescriptionGiven a n * n matrix grid of 0&#39;s and 1&#39;s only. We want to represent grid with a Quad-Tree. Return the root of the Quad-Tree representing grid. A Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes: val: True if the node represents a grid of 1’s or False if the node represents a grid of 0’s. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer. isLeaf: True if the node is a leaf node on the tree or False if the node has four children. We can construct a Quad-Tree from a two-dimensional area using the following steps: If the current grid has the same value (i.e all 1&#39;s or all 0&#39;s) set isLeaf True and set val to the value of the grid and set the four children to Null and stop. If the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo. Recurse for each of the children with the proper sub-grid. If you want to know more about the Quad-Tree, you can refer to the wiki. Quad-Tree format: You don’t need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below. It is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val]. If the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0. Example 1: Example 2: Constraints: n == grid.length == grid[i].length n == 2x where 0 &lt;= x &lt;= 6 Solution思路分析使用递归解法，分而治之 先讨论两种情况： 自底向上：将棋盘先拆分成最小的单元（四个格子），判断是否全1或全0，然后回到上一层判断四个由四个基本单元组成的大单元是否全为0或1 依次回归 自顶向下：首先判断大棋盘是否每个格子的值都一致，若是则直接返回结果，否则等分为四个小棋盘继续判断，依次递推 显然，自底向上需要将所有单元遍历，而自顶向下找到匹配的棋盘即可回归，因此采用后者的思路 对于最初始的大棋盘要判断所有的格子是否相同，时间复杂度可以达到O(n) 如果大棋盘格子不相同，判断四个小棋盘格子是否都相同的时间复杂度为4*O(n/4)=O(n) 最坏情况对格子遍历的总时间可以达到O(logn*n) ，不包括构造节点的时间 其中有很多重复计算 因此开辟一个数组记录一个矩形区块的格子值总和，以减少重复遍历 代码讲解开辟一个二位数组pre，其中pre[row][col]记录从grid[0][0]到grid[row][col]这个区块的值的总和 pre[r1][c1]-pre[r1][c0]-pre[r0][c1]+pre[r0][c0] 这个式子的值可以简化为&quot;4&quot;-&quot;2&quot;-&quot;1&quot;+&quot;3&quot; 得到的是右下角区块的值总和，由此可以快速算出一个区块的值 从而不难理解pre[i][j]=pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1]+grid[i-1][j-1] 为了方便遍历棋盘以及计算区块的总和值，将pre的边长设置为n+1 构建求和函数getSum和分治函数fun 以上两个函数使用lambda表达式构建 getSum为计算对应区块的值的总和的函数 fun首先判断当前方块的所有格子的值是否相同 如是，则返回新建叶子节点返回 如否，则等分为四个相同的棋盘，得到对应的子树，组合成一个非叶子节点作为返回值 主函数调用的fun传入大棋盘的参数，返回其返回值 时间复杂度最坏情况 空间复杂度O(n^2)"},{"title":"Sort List","date":"2024-04-20T08:56:18.000Z","url":"/2024/04/20/Sort-List/","tags":[["LeetCode","/tags/LeetCode/"],["Algorithm","/tags/Algorithm/"]],"categories":[["undefined",""]],"content":"DescriptionGiven the head of a linked list, return the list after sorting it in ascending order. Example 1: Example 2: Example 3: Constraints: The number of nodes in the list is in the range [0, 5 * 104]. -105 &lt;= Node.val &lt;= 105 SolutionO(nlogn)时间复杂度 O(1)空间复杂度归并排序 首先判断需要排序的链表是否为空 求出链表的长度传入排序函数 归并排序函数由核心三部分组成 排序前半部分 排序后半部分 将前后两部分合并 首先需要将链表分成可排序的两部分，此处使用二分法 如果count为0代表链表不可再分，直接返回头节点皆可 为了方便合并（无须记录何时遍历到当前链表的末尾）在拆分时需要将前半部分的末尾指向nullptr，因此先将part2定位到part1的末尾，在赋值给temp，然后将part2指向第二部分的头部，而temp作为part1的末尾指向nullptr 将两部分的合并是通过从头遍历两个链表进行的，为保留指针头部位置和方便遍历数组，定义了一个头节点（也可以选出两个链表中的最小节点直接作为头节点，但代码稍复杂） 分别用两个指针遍历两个链表 找出值当前值最小的节点，并将其作为合并链表的下一个节点，然后选出节点的链表的指针后移 直到其中一个链表为空，将合并链表的尾指针指向另一个链表的剩余部分皆可 返回合并后的链表 "},{"title":"Convert Sorted Array to Binary Search Tree","date":"2024-04-19T13:45:37.000Z","url":"/2024/04/19/Convert-Sorted-Array-to-Binary-Search-Tree/","tags":[["LeetCode","/tags/LeetCode/"],["Algorithm","/tags/Algorithm/"]],"categories":[["undefined",""]],"content":"DescriptionGiven an integer array nums where the elements are sorted in ascending order, convert it to a *height-balanced* binary search tree. Example 1: Example 2: Constraints: 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums is sorted in a strictly increasing order. Solution分而治之 因为列表是有序的，所以可以直接取中点来确定根节点，然后递归得到左右子树的根节点 其中因为下标为mid的节点为当前根节点，所以如果左右下标和mid相同应该设置为nullptr "},{"title":"Generate Parentheses","date":"2024-04-17T12:11:21.000Z","url":"/2024/04/17/Generate-Parentheses/","tags":[["LeetCode","/tags/LeetCode/"],["Algorithm","/tags/Algorithm/"]],"categories":[["undefined",""]],"content":"DescriptionGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. Example 1: Example 2: Constraints: 1 &lt;= n &lt;= 8 Solutionn对组合说明有左右括号各n个 以open作为左括号，close作为右括号，cur表示当前处理的括号串 进行回溯 每次cur长度到达所需的2*n时插入答案中并返回 长度没达到要求 左括号未达上限，试图插入(，调用backtrack，调用完弹出插入的字符 右括号数量小于左括号，可以匹配一个括号，试图插入(，调用backtrack，调用完弹出插入的字符 以上两种情况都不满足，直接返回 最终得到的数组即为答案 "},{"title":"Word Search","date":"2024-04-16T13:27:44.000Z","url":"/2024/04/16/Word-Search/","tags":[["LeetCode","/tags/LeetCode/"],["Algorithm","/tags/Algorithm/"]],"categories":[["undefined",""]],"content":"descriptionGiven an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. Example 1: Example 2: Example 3: Constraints: m == board.length n = board[i].length 1 &lt;= m, n &lt;= 6 1 &lt;= word.length &lt;= 15 board and word consists of only lowercase and uppercase English letters. Follow up: Could you use search pruning to make your solution faster with a larger board? Solution主函数中遍历数组中的每个格子作为起始字母调用fun判断是否能找到匹配的解 定义了bolboard作为board的映射表示是否被访问过来防止重复访问同一个格子 在fun中，记录了当前访问的格子的坐标row col，访问情况记录数组bolboard，当前匹配的字符下标index 首先如果当前字符不匹配则返回false 匹配则进入下述操作 判断字符是否匹配完，如是则返回true 如否 记录当前访问的位置，bolboard置true 设置变量temp用于返回任何一个成功的搜寻结果 按左上右下的顺序遍历数组调用fun() 为了防止搜寻失败后bolboard影响外层换方向搜寻，返回temp前应将本次 访问记录清除 "},{"title":"Best Time to Buy and Sell Stock with Cooldown","date":"2024-04-12T09:54:10.000Z","url":"/2024/04/12/Best-Time-to-Buy-and-Sell-Stock-with-Cooldown/","tags":[["LeetCode","/tags/LeetCode/"],["Algorithm","/tags/Algorithm/"]],"categories":[["undefined",""]],"content":"DescriptionYou are given an array prices where prices[i] is the price of a given stock on the ith day. Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions: After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day). Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Example 1: Example 2: Constraints: 1 &lt;= prices.length &lt;= 5000 0 &lt;= prices[i] &lt;= 1000 Solutionanalysis可以尝试使用动态规划解决 存在三种状态： 手中持有股票 处于冷冻期 手中不持有股票且不处于冷冻期 分别将以上三种状态标记为hold freeze not,最大余额为f0 f1 f2 对于hold状态，有两种情况：目前持有股票和目前未持有股票 对于目前持有股票，无须操作，余额仍为f0 对于目前未持有股票，要达到hold状态需要购买当天股票，那么前一天的状态必须是hold，由此余额为f2-prices[i] 由此可以得到状态hold收益的最大值为max(f0,f2-prices[i]) 对于cold状态只有一种情况：前一天状态为hold，当天卖出了股票，收益为f0+prices[i] 因此cold状态的最大收益为f0+prices[i] 对于not状态有两种情况：前一天是状态为not、前一天状态为cold 对于前一天状态为not，无需操作，余额仍为f2 对于前一天状态为cold，余额为前一天的cold状态的余额，即f1 由此可以得到状态not的取得收益的最大值为max(f1,f2) 最后结束天要想得到收益最大值有两种情况：当天卖出股票处于冷冻期cold和当前未持有股票且不处于冷冻状态not，取两者最大值即可max(f1,f2) conclusion对于本题来说，采用暴力算法需要将尝试每一天的hold cold not的可能情况 而动态规划记录了三种状态在某一天收益最大值的可能性，而不是一味记录所有可能的收入情况，极大减少了重复计算量 code"},{"title":"Linux expand disk","date":"2024-04-11T10:51:27.000Z","url":"/2024/04/11/Linux-expand-disk/","categories":[["undefined",""]],"content":"重要！操作前务必备份！ 务必备份！ 务必备份！ 分配硬盘空间可在VMware中分配 本文中扩大到128GB 但是我们发现分配后的磁盘空间不能直接利用，还需要为磁盘分区或扩容 查看磁盘分区结构使用lsblk可查看 其中sda1和sda2之和远小于分配后的sda容量，究其原因是有一部分空间未分配 扩大分区空间查看分区资源具体数值 使用以上命令可以查看各分区资源具体数值 进入分区调整界面接下来调整分区大小,，进入分区调整界面 以下为分区调整的页面 删除分区 d代表删除分区，2代表sda2分区 创建分区 n代表创建分区,p代表主分区，2代表sda2，后面扇区起始值、删除值自定，理论上包括原来的删除的区域数据就不会丢，默认为最小和最大值 设置分区类型采用LVM模式 8e 保存并退出 因为使用的是虚拟机，保存并退出后要重启虚拟机 调整物理卷大小验证分区大小是否调整此时执行lsblk就会发现sda2空间增长了 调整物理卷大小 现在可以sda2物理卷可以利用上分区新分配的空间了 关于卷组、物理卷、逻辑卷的描述可以看最后的讲解 vgdisplay查看卷组 pvdisplay查看物理卷 lvdisplay查看逻辑卷 可以看到重新分配的物理卷后，卷组总大小扩大到127G了 扩充逻辑卷 lvextend扩充逻辑卷命令 -l +100%FREE 按比例扩充 -L 10GB 按数值扩充 /dev/mapper/centos-root 要扩充的逻辑卷名称 输出 调整文件系统大小 如果使用的时XFS文件系统，要使用xfs_growfs /dev/mapper/centos-root挂载的逻辑卷名 验证 显示文件系统磁盘利用率的命令 -h为以人类可读的形式输出 可以看到文件系统根目录的空间扩充了 卷组、物理卷、逻辑卷讲解 LVM（Logical Volume Manager）中的三个重要概念 物理卷(Physical Volume)：LVM的基本构建单元，通常对应物理磁盘或分区 卷组(Volume Group)：一个或多个物理卷的集合，这些物理卷被组合在一起形成逻辑的储存池，可以动态增长和缩小而不用考虑底层的物理设备细节 逻辑卷(Logical Group)：卷组中划分出来的逻辑储存空间，可以被格式化并挂载为文件系统，从而像常规分区一样使用，但更具有灵活的管理能力 "},{"title":"docker command","date":"2024-04-09T13:01:21.000Z","url":"/2024/04/09/docker-command/","categories":[["undefined",""]],"content":"启动docker可以通过以下命令启动docker的守护程序 systemctl启动的应用程序，通过搜索后缀为.service的文件,存放目录为/usr/lib/systemd/system/ 例如docker的服务文件为docker.service 配置切换国内镜像 在/etc/docker/daemon.json中修改，若不存在则创建该文件 修改成以上json数据 重新加载 Systemd 守护程序管理器的配置文件 重启docker服务 网络查看网络 删除网络 创建网络 容器操作运行容器 -d 后台运行 --name &lt;NAME&gt; 设置容器名 -m 4GB 分配4GB的内存 -e 设置环境变量 --privileged 分配特权 --net &lt;NETWORK NAME&gt; 在指定网络下运行 -p &lt;PORT&gt;:&lt;PORT&gt; 开放端口 查询容器 -a查看所有容器包括停止的容器 停止容器 删除容器 进入容器 镜像操作查询镜像 删除镜像 拉取镜像 "},{"title":"elasticsearch deployment","date":"2024-04-09T10:42:26.000Z","url":"/2024/04/09/elasticsearch-deployment/","tags":[["LeetCode","/tags/LeetCode/"]],"categories":[["undefined",""]],"content":"Run ElasticSearchCreate a new docker network Pull the Elasticsearch Docker image Edit config filecopy config file edit elasticsearch.yml Start an Elasticsearch container remember to copy directory data and plugins 命令解释： -e &quot;cluster.name=es-docker-cluster&quot;：设置集群名称 -e &quot;http.host=0.0.0.0&quot;：监听的地址，可以外网访问 -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;：内存大小 -e &quot;discovery.type=single-node&quot;：非集群模式 -v es-data:/usr/share/elasticsearch/data：挂载逻辑卷，绑定es的数据目录 -v es-logs:/usr/share/elasticsearch/logs：挂载逻辑卷，绑定es的日志目录 -v es-plugins:/usr/share/elasticsearch/plugins：挂载逻辑卷，绑定es的插件目录 --privileged：授予逻辑卷访问权 --network es-net ：加入一个名为es-net的网络中 -p 9200:9200：端口映射配置 9200: Elasticsearch HTTP API 端口，用于客户端与 Elasticsearch 集群进行通信。这是与 Elasticsearch 进行索引、搜索等操作的主要端口。 9300: Elasticsearch 内部节点之间的通信端口。这个端口用于节点之间的集群通信，用于复制索引数据、选举主节点等集群操作。 -i：表示以交互模式运行容器，即使没有终端连接也能保持容器的标准输入 (stdin) 打开。 -t：分配一个伪终端 (pseudo-TTY)，这样可以在容器内部通过命令行与用户进行交互。 Config the certificateenter the container generates a new local certificate authority generates a new certificate with the certificate authority Copy the generated elastic password and enrollment tokenThese credentials are only shown when you start Elasticsearch for the first time. You can regenerate the credentials using the following commands. -s kibana 表示为 Kibana 生成 Enrollment Token -u elastic表示使用用户名 elastic 进行操作。 You can store the elastic password as an environment variable in your shell. Copy the http_ca.crt SSL certificate from the container to your local machine Make a REST API call to Elasticsearch to ensure the Elasticsearch container is running Run KibanaPull the Kibana Docker image Start a Kibana container Add elasticsearch user Then will print the password of kibana_system Edit config filecopy config file edit kibana.yml Rerun Kibanastop and rm kibana start kibana When Kibana starts, it outputs a unique generated link to the terminal. To access Kibana, open this link in a web browser Enter the enrollment tokenIn your browser, enter the enrollment token that was generated when you started Elasticsearch. To regenerate the token, run: Log in to KibanaLog in to Kibana as the elastic user with the password that was generated when you started Elasticsearch. To regenerate the password, run: "},{"title":"动态规划背包问题","date":"2024-04-09T05:05:48.000Z","url":"/2024/04/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","tags":[["Algorithm","/tags/Algorithm/"]],"categories":[["undefined",""]],"content":"01背包问题Description有一个固定大小的背包，以及一组物品，每件物品都有自己的重量和价值，需要确定装入背包的物品的组合，使得装入背包的物品总重量不超过背包的容量，且所装物品的总价值最大。 每种物品只能选择装入一次，即要么装入背包，要么不装入。 Solution第i个物品的重量为weights[i] 第i个物品的价值为values[i] 背包的最大容量为capacity 定义一个二位数组dp[i][j]表示前个i物品装入容量为j的背包的最大价值 第一重循环从前个1物品到前n个物品依次遍历 第二重循环从背包容量为1到背包容量为capacity依次遍历 显然可知前0个物品的背包最大价值为0，背包最大容量为0的最大价值为0 第二重循环遍历时分两种情况，第i个物品的质量大于当前背包最大容量，dp取前i-1个物品时的背包容量；第i个物品的质量小于等于当前背包最大容量，取前i-1个物品时背包容量为j的最大容量（i-1的循环已得出）与前i-1个物品时（背包容量为j减去当前第i个物品的质量）加上当前物品的价值之间的最大值注意第i个物品的质量和价值的下标为i-1 最后得到的dp[n][capacity]即为所求最大值 完全背包问题Description有一个固定大小的背包，以及一组物品，每件物品都有自己的重量和价值，需要确定装入背包的物品的组合，使得装入背包的物品总重量不超过背包的容量，且所装物品的总价值最大。 每种物品可以无限次选择装入，即可以重复装入多次。 Solution在01背包问题中由于每种物品只能放一次，dp[i][j]只能是dp[i - 1][j]与前i-1个物品减去当前物品质量weight[i-1]得到的dp[i-1][j - weights[i-1]]加上当前物品价值之间的最大值 而完全背包问题中，可以重复加入同一物品，即与可能加入过本物品的背包再加入当前物品dp[i][j - weights[i-1]] + values[i-1])相比 总结动态规划（Dynamic Programming，DP）是一种解决多阶段决策问题的数学方法，通常用于优化问题。其原理基于将一个问题分解成多个子问题，并且通过对这些子问题的解进行存储，以避免重复计算，从而减少时间复杂度。 动态规划的核心思想是利用之前计算过的结果来减少重复计算，从而提高算法的效率。它通常适用于具有最优子结构性质和重叠子问题性质的问题。最优子结构指的是问题的最优解可以通过子问题的最优解来构造，而重叠子问题指的是问题的子问题会被重复求解多次。 如在本问题中，将问题划分为n个小问题，记录此前的最大价值，以此为依据减少计算量 动态规划一般有两种解决方法：自顶向下的备忘录法和自底向上的递推法。备忘录法通常采用递归的方式解决问题，并使用一个数组（通常称为备忘录）来存储已经计算过的结果，避免重复计算。递推法则是从最小的子问题开始，逐步推导出更大规模问题的解，直到求解出整个问题的解。"},{"title":"Best Time to Buy and Sell Stock IV","date":"2024-04-08T09:16:58.000Z","url":"/2024/04/08/Best-Time-to-Buy-and-Sell-Stock-IV/","tags":[["LeetCode","/tags/LeetCode/"],["Algorithm","/tags/Algorithm/"]],"categories":[["undefined",""]],"content":"DescriptionYou are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k. Find the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Example 1: Example 2: Constraints: 1 &lt;= k &lt;= 100 1 &lt;= prices.length &lt;= 1000 0 &lt;= prices[i] &lt;= 1000 Solution思路同Best Time to Buy and Sell Stock III "},{"title":"Best Time to Buy and Sell Stock III","date":"2024-04-07T13:18:12.000Z","url":"/2024/04/07/Best-Time-to-Buy-and-Sell-Stock-III/","tags":[["LeetCode","/tags/LeetCode/"],["Algorithm","/tags/Algorithm/"]],"categories":[["undefined",""]],"content":"DescriptionYou are given an array prices where prices[i] is the price of a given stock on the ith day. Find the maximum profit you can achieve. You may complete at most two transactions. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Example 1: Example 2: Example 3: Constraints: 1 &lt;= prices.length &lt;= 105 0 &lt;= prices[i] &lt;= 105 Solution解法一分为四种状态，第一次购买后，第一次卖出后，第二次购买后，第二次卖出后，分别为dp[i][0] dp[i][1] dp[i][2] dp[i][3] ，其中 i代表天数 第一天假设买了股票，所以设置dp[0][0]为prices[0] 至于设置dp[0][2]为prices[0],是为了防止在只卖一次的情况下对最终结果造成干扰，因为第一次买入值为负，但dp[0][2]的值为0，假设只买入一次，在股票涨到最高值时，dp[i][0]依旧小于0因此dp[i][1]（即卖出后得到的钱），小于股票最高价；而dp[i][3]却为股票最高价导致最后得到的结果出现偏差。得到一个结论：变量使用前要记得初始化为正确的值 解法二在解法一中可以发现,dp数组只访问了上一次的值，而与此前历史的值无关，因此二维数组可以简化为四个变量dp0 dp1 dp2 dp3 "},{"title":"Linux command","date":"2024-04-04T14:22:12.000Z","url":"/2024/04/04/Linux-command/","categories":[["undefined",""]],"content":"本机与虚拟机之间交互 使用SSH连接Linux服务器： 本机与Linux上传下载文件 从Linux服务器下载文件（文件夹）到本机 从本机上传文件（文件夹）到Linux服务器 防火墙操作 Linux 开放端口 开启防火墙 systemctl start firewalld 开放指定端口firewall-cmd --zone=public --add-port=8848/tcp --permanent--zone 作用域-add-port=1935/tcp 添加端口，格式为：端口&#x2F;通讯协议--remove-port=1935/tcp 关闭指定端口--permanent 永久生效，没有此参数重启后失效 查看指定端口firewall-cmd --list-ports 重启防火墙firewall-cmd --reload 查看端口号netstat -ntlp 查看当前所有tcp端口netstat -ntulp |grep 8848 查看所有8848端口使用情况 查询进程端口占用 ps -ef | grep [进程名] 文件操作 Linux 操作文件 rm -rf 目录名 删除目录连同目录下所有文件 .tar.gz 和 .tgz 解压：tar -zxvf FileName.tar.gz 压缩：tar -zcvf FileName.tar.gz DirName mkdir [-p] dirName-p 确保目录名称存在，不存在的就建一个。 mv file1 /tmp 移动到指定目录 mv file1 file2 重命名文件 mv dir1 dir2 移动目录dir1到dir2 mv file1 file2 dir1 移动多个文件到目标目录 mv *.pdf ~/Documents cp source.txt destination.txt 复制文件到另一个位置 cp -r source_dir destination_dir 递归复制整个目录 ip操作 IPv4 转发 sysctl net.ipv4.ip_forward 查看虚拟机是否开启ipv4转发 sysctl -w net.ipv4.ip_forward=1 开启ipv4转发 磁盘操作查看虚拟机磁盘总占用情况 查看指定目录磁盘占用 查看当前目录各目录文件磁盘占用情况 查看系统中所有硬盘和分区情况 "},{"title":"combinations and permutation","date":"2024-04-04T10:43:27.000Z","url":"/2024/04/04/combinations-and-permutation/","tags":[["Algorithm","/tags/Algorithm/"]],"categories":[["undefined",""]],"content":" Combinations Permutations "}]